<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://amberyic.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<script data-ad-client="ca-pub-4128258433761966" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <meta name="description" content="贪心算法在思想及其实现都比较简单易懂。我们数据结构中讲解过huffman tree构建及图的最小生成树涉及贪心算法。经典例题:1)活动时间安排问题,2)背包问题,3)线段覆盖(lines cover),4)数字组合问题,5)找零钱的问题,6)多机调度问题,7)小船过河问题,8)销售比赛,9)Huffman编码,10)Dijkstra算法,11)最小生成树算法">
<meta property="og:type" content="article">
<meta property="og:title" content="五大经典算法-2.贪心算法">
<meta property="og:url" content="http://amberyic.github.io/2020/04/15/5-classic-algorithms-2-greedy-algorithm/index.html">
<meta property="og:site_name" content="Zhang Hao&#39;s Blog">
<meta property="og:description" content="贪心算法在思想及其实现都比较简单易懂。我们数据结构中讲解过huffman tree构建及图的最小生成树涉及贪心算法。经典例题:1)活动时间安排问题,2)背包问题,3)线段覆盖(lines cover),4)数字组合问题,5)找零钱的问题,6)多机调度问题,7)小船过河问题,8)销售比赛,9)Huffman编码,10)Dijkstra算法,11)最小生成树算法">
<meta property="article:published_time" content="2020-04-14T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-14T08:43:01.387Z">
<meta property="article:author" content="ZhangHao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://amberyic.github.io/2020/04/15/5-classic-algorithms-2-greedy-algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>五大经典算法-2.贪心算法 | Zhang Hao's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-166608124-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-166608124-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zhang Hao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">算法工程师的世界</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://amberyic.github.io/2020/04/15/5-classic-algorithms-2-greedy-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="ZhangHao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang Hao's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          五大经典算法-2.贪心算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-15T00:00:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-14 16:43:01" itemprop="dateModified" datetime="2020-05-14T16:43:01+08:00">2020-05-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>贪心算法在思想及其实现都比较简单易懂。我们数据结构中讲解过huffman tree构建及图的最小生成树涉及贪心算法。<br>经典例题:1)活动时间安排问题,2)背包问题,3)线段覆盖(lines cover),4)数字组合问题,5)找零钱的问题,6)多机调度问题,7)小船过河问题,8)销售比赛,9)Huffman编码,10)Dijkstra算法,11)最小生成树算法</p>
</blockquote>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul>
<li>1.建立数学模型来描述问题；</li>
<li>2.把求解的问题分成若干个子问题；</li>
<li>3.对每一子问题求解，得到子问题的局部最优解；</li>
<li>4.把子问题的局部最优解合成原来问题的一个解。</li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="活动时间安排问题"><a href="#活动时间安排问题" class="headerlink" title="活动时间安排问题"></a>活动时间安排问题</h3><ul>
<li>题目<blockquote>
<p>设有N个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用，每个活动都有一个使用活动的开始si和结束时间fi，即他的使用区间为(si,fi),现在要求你分配活动占用时间表，即哪些活动占用该会议室，哪些不占用，使得他们不冲突，要求是尽可能多的使参加的活动最大化，即所占时间区间最大化！</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>上图为每个活动的开始和结束时间，我们的任务就是设计程序输出哪些活动可以占用会议室！</p>
</blockquote>
<ul>
<li>分析</li>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void GreedyChoose(int len,int *s,int *f,bool *flag);</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  int s[11] &#x3D;&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</span><br><span class="line">  int f[11] &#x3D;&#123;4,5,6,7,8,9,10,11,12,13,14&#125;;</span><br><span class="line"></span><br><span class="line">  bool mark[11] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  GreedyChoose(11,s,f,mark);</span><br><span class="line">  for(int i&#x3D;0;i&lt;11;i++)</span><br><span class="line">    if (mark[i])</span><br><span class="line">      cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GreedyChoose(int len,int *s,int *f,bool *flag) &#123;</span><br><span class="line">  flag[0] &#x3D; true;</span><br><span class="line">  int j &#x3D; 0;</span><br><span class="line">  for(int i&#x3D;1;i&lt;len;++i)</span><br><span class="line">    if (s[i] &gt;&#x3D; f[j]) &#123;</span><br><span class="line">      flag[i] &#x3D; true;</span><br><span class="line">      j &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li>题目<blockquote>
<p>有一个背包，背包容量是M=150。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量.</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">物品</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重量</td>
<td align="center">35</td>
<td align="center">30</td>
<td align="center">60</td>
<td align="center">50</td>
<td align="center">40</td>
</tr>
<tr>
<td align="center">价值</td>
<td align="center">10</td>
<td align="center">40</td>
<td align="center">30</td>
<td align="center">50</td>
<td align="center">35</td>
</tr>
</tbody></table>
<ul>
<li><p>分析</p>
<blockquote>
<p>目标函数： ∑pi最大<br>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)。<br>(1)根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？<br>(2)每次挑选所占重量最小的物品装入是否能得到最优解？<br>(3)每次选取单位重量价值最大的物品，成为解本题的策略。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>可惜的是，它需要证明后才能真正运用到题目的算法中。<br>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。<br>对于背包问题中的3种贪心策略，都是无法成立(无法被证明)的，解释如下：<br>贪心策略：选取价值最大者。反例：<br>W=30<br>物品：A B C<br>重量：28 12 12<br>价值：30 20 20<br>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。<br>(2)贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。<br>(3)贪心策略：选取单位重量价值最大的物品。反例：<br>W=30<br>物品：A B C<br>重量：28 20 10<br>价值：28 20 10<br>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。<br>但是果在条件中加一句当遇见单位价值相同的时候,优先装重量小的,这样的问题就可以解决.</p>
<p>所以需要说明的是，贪心算法可以与随机化算法一起使用，具体的例子就不再多举了。<br>(因为这一类算法普及性不高，而且技术含量是非常高的，需要通过一些反例确定随机的对象是什么，<br>随机程度如何，但也是不能保证完全正确，只能是极大的几率正确)。</p>
</blockquote>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">  float weight;</span><br><span class="line">  float value;</span><br><span class="line">  bool mark;</span><br><span class="line">  char char_mark;</span><br><span class="line">  float pre_weight_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  float Weight[7] &#x3D; &#123;35,30,60,50,40,15,20&#125;;</span><br><span class="line">  float Value [7] &#x3D; &#123;10,40,30,50,35,40,30&#125;;</span><br><span class="line">  Node array[7];</span><br><span class="line">  for(int i&#x3D;0; i&lt;7; i++) &#123;</span><br><span class="line">    array[i].value &#x3D; Value[i];</span><br><span class="line">    array[i].weight &#x3D; Weight[i];</span><br><span class="line">    array[i].char_mark &#x3D; 65 + i;</span><br><span class="line">    array[i].mark &#x3D; false;</span><br><span class="line">    array[i].pre_weight_value &#x3D; Value[i] &#x2F; Weight[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(i&#x3D;0;i&lt;7;i++)</span><br><span class="line">    cout&lt;&lt;array[i].pre_weight_value&lt;&lt;&quot; &quot;;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  float weight_all&#x3D;0.0;</span><br><span class="line">  float value_all &#x3D; 0.0;</span><br><span class="line">  float max &#x3D; 0.0;</span><br><span class="line">  char charArray[7];</span><br><span class="line">  int flag,n &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  while(weight_all &lt;&#x3D; 150) &#123;</span><br><span class="line">    for(int index&#x3D;0;index &lt; 7; ++index) &#123;</span><br><span class="line">      if (array[index].pre_weight_value &gt; max &amp;&amp; array[index].mark &#x3D;&#x3D; false) &#123;</span><br><span class="line">        max &#x3D; array[index].pre_weight_value ;</span><br><span class="line">        flag &#x3D; index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    charArray[n++] &#x3D; array[flag].char_mark;</span><br><span class="line">    array[flag].mark &#x3D; true;</span><br><span class="line">    weight_all +&#x3D; array[flag].weight;</span><br><span class="line">    value_all +&#x3D; array[flag].value;</span><br><span class="line">    max &#x3D; 0.0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(i&#x3D;0;i&lt;n-1;i++)</span><br><span class="line">    cout&lt;&lt;charArray[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;&quot;weight_all:&quot;&lt;&lt;weight_all- array[n-1].weight&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;&quot;value_all:&quot;&lt;&lt;value_all&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线段覆盖-lines-cover"><a href="#线段覆盖-lines-cover" class="headerlink" title="线段覆盖(lines cover)"></a>线段覆盖(lines cover)</h3><ul>
<li>题目<blockquote>
<p>在一维空间中告诉你N条线段的起始坐标与终止坐标，要求求出这些线段一共覆盖了多大的长度。<br>为了方便说明，我们采用上述表格中的数据代表10条线段的起始点和终点，注意，这里是用起始点为顺序进行排列，和上面的不一样，知道了这些我们就可以着手开始设计这个程序：</p>
</blockquote>
</li>
</ul>
<ul>
<li>分析</li>
</ul>
<ul>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  int s[10] &#x3D; &#123;2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line">  int f[10] &#x3D; &#123;3,5,7,6,9,8,12,10,13,15&#125;;</span><br><span class="line">  int TotalLength &#x3D; (3-2);</span><br><span class="line"></span><br><span class="line">  for(int i&#x3D;1,int j&#x3D;0; i&lt;10 ; ++i) &#123;</span><br><span class="line">    if (s[i] &gt;&#x3D; f[j]) &#123;</span><br><span class="line">      TotalLength +&#x3D; (f[i]-s[i]);</span><br><span class="line">      j &#x3D; i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (f[i] &lt;&#x3D; f[j]) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        TotalLength +&#x3D; f[i] - f[j];</span><br><span class="line">        j &#x3D; i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;TotalLength&lt;&lt;endl;</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数字组合问题"><a href="#数字组合问题" class="headerlink" title="数字组合问题"></a>数字组合问题</h3><ul>
<li>题目<blockquote>
<p>设有N个正整数，现在需要你设计一个程序，使他们连接在一起成为最大的数字，例3个整数 12,456,342 很明显是45634212为最大，4个整数 342，45,7,98显然为98745342最大<br>程序要求：输入整数N 接下来一行输入N个数字，最后一行输出最大的那个数字！</p>
</blockquote>
</li>
</ul>
<ul>
<li>分析<blockquote>
<p>拿到这题目，看起要来也简单，看起来也难，简单在什么地方，简单在好像就是寻找哪个开头最大，然后连在一起就是了，难在如果N大了，假如几千几万，好像就不是那么回事了，要解答这个题目需要选对合适的贪心策略，并不是把数字由大排到小那么简单，网上的解法是将数字转化为字符串，比如a+b和b+a，用strcmp函数比较一下就知道谁大，也就知道了谁该排在谁前面，不过我觉得这个完全没必要，在这里我采用一种比较巧妙的方法来解答，不知道大家还记得冒泡排序法不，那是排序最早接触的一种方法，我们先看看它的源代码：</p>
</blockquote>
</li>
</ul>
<ul>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  int array[10];</span><br><span class="line">  for(int i&#x3D;0;i&lt;10;i++)</span><br><span class="line">    cin&gt;&gt;array[i];</span><br><span class="line"></span><br><span class="line">  int temp;</span><br><span class="line">  for(i&#x3D;0; i&lt;&#x3D;9 ; ++i)</span><br><span class="line">    for(int j&#x3D;0;j&lt;10-1-i;j++)</span><br><span class="line">      if (array[j] &gt; array[j+1]) &#123;</span><br><span class="line">        temp &#x3D; array[j];</span><br><span class="line">        array[j] &#x3D; array[j+1];</span><br><span class="line">        array[j+1] &#x3D; temp;</span><br><span class="line">      &#125;</span><br><span class="line">  for(i&#x3D;0;i&lt;10;i++)</span><br><span class="line">    cout&lt;&lt;array[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="找零钱的问题"><a href="#找零钱的问题" class="headerlink" title="找零钱的问题"></a>找零钱的问题</h3><ul>
<li>题目<blockquote>
<p>在贪心算法里面最常见的莫过于找零钱的问题了，题目大意如下，对于人民币的面值有1元 5元 10元 20元 50元 100元，下面要求设计一个程序，输入找零的钱，输出找钱方案中最少张数的方案，比如123元，最少是1张100的，1张20的，3张1元的，一共5张！</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>分析</p>
<blockquote>
<p>这样的题目运用的贪心策略是每次选择最大的钱，如果最后超过了，再选择次大的面值，然后次次大的面值，一直到最后与找的钱相等，这种情况大家再熟悉不过了，下面就直接看源代码：</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  int MoneyClass[6] &#x3D; &#123;100,50,20,10,5,1&#125;; &#x2F;&#x2F;记录钱的面值</span><br><span class="line">  int MoneyIndex [6] &#x3D;&#123;0&#125;;           &#x2F;&#x2F;记录每种面值的数量</span><br><span class="line">  int MoneyAll,MoneyCount &#x3D; 0,count&#x3D;0;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;&quot;please enter the all money you want to exchange:&quot;&lt;&lt;endl;</span><br><span class="line">  cin&gt;&gt;MoneyAll;</span><br><span class="line"></span><br><span class="line">  for(int i&#x3D;0;i&lt;6;) &#123;    &#x2F;&#x2F;只有这个循环才是主体</span><br><span class="line">    if ( MoneyCount+MoneyClass[i] &gt; MoneyAll) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MoneyCount +&#x3D; MoneyClass[i];</span><br><span class="line">    ++ MoneyIndex[i];</span><br><span class="line">    ++ count;</span><br><span class="line"></span><br><span class="line">    if (MoneyCount &#x3D;&#x3D; MoneyAll)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(i&#x3D;0;i&lt;6;++i) &#123;     &#x2F;&#x2F;控制输出的循环</span><br><span class="line">    if (MoneyIndex[i] !&#x3D;0 ) &#123;</span><br><span class="line">      switch(i) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        cout&lt;&lt;&quot;the 100 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        cout&lt;&lt;&quot;the 50 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        cout&lt;&lt;&quot;the 20 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        cout&lt;&lt;&quot;the 10 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        cout&lt;&lt;&quot;the 5 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        cout&lt;&lt;&quot;the 1 have:&quot;&lt;&lt;MoneyIndex[i]&lt;&lt;endl;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;&quot;the total money have:&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多机调度问题"><a href="#多机调度问题" class="headerlink" title="多机调度问题"></a>多机调度问题</h3><ul>
<li><p>题目</p>
<blockquote>
<p>n个作业组成的作业集，可由m台相同机器加工处理。要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。作业不能拆分成更小的子作业；每个作业均可在任何一台机器上加工处理。</p>
</blockquote>
</li>
<li><p>分析</p>
<blockquote>
<p>这个问题是NP完全问题，还没有有效的解法(求最优解)，但是可以用贪心选择策略设计出较好的近似算法(求次优解)。当n&lt;=m时，只要将作业时间区间分配给作业即可；当n&gt;m时，首先将n个作业从大到小排序，然后依此顺序将作业分配给空闲的处理机。也就是说从剩下的作业中，选择需要处理时间最长的，然后依次选择处理时间次长的，直到所有的作业全部处理完毕，或者机器不能再处理其他作业为止。如果我们每次是将需要处理时间最短的作业分配给空闲的机器，那么可能就会出现其它所有作业都处理完了只剩所需时间最长的作业在处理的情况，这样势必效率较低。在下面的代码中没有讨论n和m的大小关系，把这两种情况合二为一了。</p>
</blockquote>
</li>
</ul>
<ul>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int speed[10010];</span><br><span class="line">int mintime[110];</span><br><span class="line"></span><br><span class="line">bool cmp( const int &amp;x,const int &amp;y) &#123;</span><br><span class="line">    return x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int n,m;</span><br><span class="line">  memset(speed,0,sizeof(speed));</span><br><span class="line">   memset(mintime,0,sizeof(mintime));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">     for(int i&#x3D;0;i&lt;n;++i) cin&gt;&gt;speed[i];</span><br><span class="line">    sort(speed,speed+n,cmp);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;++i) &#123;</span><br><span class="line">      *min_element(mintime,mintime+m)+&#x3D;speed[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;*max_element(mintime,mintime+m)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="小船过河问题"><a href="#小船过河问题" class="headerlink" title="小船过河问题"></a>小船过河问题</h3><ul>
<li><p>题目</p>
<blockquote>
<p>POJ1700是一道经典的贪心算法例题。题目大意是只有一艘船，能乘2人，船的运行速度为2人中较慢一人的速度，过去后还需一个人把船划回来，问把n个人运到对岸，最少需要多久。</p>
</blockquote>
</li>
<li><p>分析</p>
<blockquote>
<p>先将所有人过河所需的时间按照升序排序，我们考虑把单独过河所需要时间最多的两个旅行者送到对岸去，有两种方式：<br>1.最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，所需时间为：t[0]+2<em>t[1]+t[n-1]；<br>2.最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，所需时间为：2</em>t[0]+t[n-2]+t[n-1]。<br>算一下就知道，除此之外的其它情况用的时间一定更多。每次都运送耗时最长的两人而不影响其它人，问题具有贪心子结构的性质。</p>
</blockquote>
</li>
</ul>
<ul>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int a[1000],t,n,sum;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  while(t--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    while(n&gt;3) &#123;</span><br><span class="line">      sum&#x3D;min(sum+a[1]+a[0]+a[n-1]+a[1],sum+a[n-1]+a[0]+a[n-2]+a[0]);</span><br><span class="line">      n-&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n&#x3D;&#x3D;3) sum+&#x3D;a[0]+a[1]+a[2];</span><br><span class="line">    else if (n&#x3D;&#x3D;2) sum+&#x3D;a[1];</span><br><span class="line">    else sum+&#x3D;a[0];</span><br><span class="line">    printf(&quot;%d\n&quot;,sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销售比赛"><a href="#销售比赛" class="headerlink" title="销售比赛"></a>销售比赛</h3><ul>
<li><p>题目</p>
<blockquote>
<p>假设有偶数天，要求每天必须买一件物品或者卖一件物品，只能选择一种操作并且不能不选，开始手上没有这种物品。现在给你每天的物品价格表，要求计算最大收益。</p>
</blockquote>
</li>
<li><p>分析</p>
<blockquote>
<p>首先要明白，第一天必须买，最后一天必须卖，并且最后手上没有物品。那么除了第一天和最后一天之外我们每次取两天，小的买大的卖，并且把卖的价格放进一个最小堆。如果买的价格比堆顶还大，就交换。这样我们保证了卖的价格总是大于买的价格，一定能取得最大收益。</p>
</blockquote>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long int price[100010],t,n,res;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  ios::sync_with_stdio(false);</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  while(t--) &#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;long long int, vector&lt;long long int&gt;, greater&lt;long long int&gt; &gt; q;</span><br><span class="line">    res&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123;</span><br><span class="line">      cin&gt;&gt;price[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res-&#x3D;price[1];</span><br><span class="line">    res+&#x3D;price[n];</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n-1;i&#x3D;i+2) &#123;</span><br><span class="line">      long long int buy&#x3D;min(price[i],price[i+1]);</span><br><span class="line">      long long int sell&#x3D;max(price[i],price[i+1]);</span><br><span class="line">      if (!q.empty()) &#123;</span><br><span class="line">        if (buy&gt;q.top()) &#123;</span><br><span class="line">          res&#x3D;res-2*q.top()+buy+sell;</span><br><span class="line">          q.pop();</span><br><span class="line">          q.push(buy);</span><br><span class="line">          q.push(sell);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          res&#x3D;res-buy+sell;</span><br><span class="line">          q.push(sell);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res&#x3D;res-buy+sell;</span><br><span class="line">        q.push(sell);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/10/5-classic-algorithms-1-exhaustive-method/" rel="prev" title="五大经典算法-1.穷举法">
      <i class="fa fa-chevron-left"></i> 五大经典算法-1.穷举法
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/20/5-classic-algorithms-3-divide-and-conquer/" rel="next" title="五大经典算法-3.分治法">
      五大经典算法-3.分治法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思想"><span class="nav-number">2.</span> <span class="nav-text">思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题目"><span class="nav-number">3.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#活动时间安排问题"><span class="nav-number">3.1.</span> <span class="nav-text">活动时间安排问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">3.2.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段覆盖-lines-cover"><span class="nav-number">3.3.</span> <span class="nav-text">线段覆盖(lines cover)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字组合问题"><span class="nav-number">3.4.</span> <span class="nav-text">数字组合问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找零钱的问题"><span class="nav-number">3.5.</span> <span class="nav-text">找零钱的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多机调度问题"><span class="nav-number">3.6.</span> <span class="nav-text">多机调度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小船过河问题"><span class="nav-number">3.7.</span> <span class="nav-text">小船过河问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销售比赛"><span class="nav-number">3.8.</span> <span class="nav-text">销售比赛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman编码"><span class="nav-number">3.9.</span> <span class="nav-text">Huffman编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">3.10.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树算法"><span class="nav-number">3.11.</span> <span class="nav-text">最小生成树算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhangHao"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">ZhangHao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/amberyic" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;amberyic" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhanghaokdd@163.com" title="E-Mail → mailto:zhanghaokdd@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/chanming1989" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;chanming1989" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/amberyic" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;amberyic" rel="noopener" target="_blank"><i class="fa fa-fw fa-gratipay"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/amberyic" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;amberyic" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/amberyic" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;amberyic" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangHao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>


<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
        本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        本站访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
