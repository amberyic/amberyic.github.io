<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="ZhangHao">


    <meta name="subtitle" content="算法工程师的世界">



    <meta name="keywords" content="算法工程师 机器学习 深度学习 推荐系统 计算广告">


<title>五大经典算法|3.分治法 | 张浩写字的地方</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-166608124-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-166608124-1');
</script>


<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="张浩写字的地方" type="application/atom+xml">
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ZhangHao&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ZhangHao&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">五大经典算法|3.分治法</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ZhangHao</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 20, 2020</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">五大经典算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>分治算法（Divide And Conquer）把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<a id="more"></a>

<h2 id="分治算法的概念"><a href="#分治算法的概念" class="headerlink" title="分治算法的概念"></a>分治算法的概念</h2><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<h2 id="分治算法的思想"><a href="#分治算法的思想" class="headerlink" title="分治算法的思想"></a>分治算法的思想</h2><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>对于一个规模为n的问题，若该问题可以容易地解决(比如说规模n较小)则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h2 id="分治法能解决的问题特征"><a href="#分治法能解决的问题特征" class="headerlink" title="分治法能解决的问题特征"></a>分治法能解决的问题特征</h2><ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ul>
<h2 id="分治法解决问题的基本步骤"><a href="#分治法解决问题的基本步骤" class="headerlink" title="分治法解决问题的基本步骤"></a>分治法解决问题的基本步骤</h2><ul>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ul>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>在计算机科学中，二分搜索（binary search），也称折半搜索（half-interval search）、对数搜索（logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。</p>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>给定一个有序的数组，查找 value 是否在数组中，不存在返回 -1。</p>
<p>例如：{ 1, 2, 3, 4, 5 } 找 3，返回下标 2（下标从 0 开始计算）。</p>
<details>
  <summary>二分查找算法C语言实现代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">29</span>,<span class="number">55</span>&#125;;<span class="comment">//数组中的数（由小到大）</span></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//要找的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">found</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=x+(y-x)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;y) &#123; <span class="comment">//查找完毕没有找到答案，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[m]==k) </span><br><span class="line">        <span class="keyword">return</span> m; <span class="comment">//找到!返回位置.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[m]&gt;k)</span><br><span class="line">        <span class="keyword">return</span> found(x,m<span class="number">-1</span>);<span class="comment">//找左边</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> found(m+<span class="number">1</span>,y);<span class="comment">//找右边</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;<span class="comment">//输入要找的数字c语言把cin换为scanf即可</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;found(<span class="number">0</span>,<span class="number">9</span>);<span class="comment">//从数组a[0]到a[9]c语言把cout换为printf即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><p>对于两个相同位数的大数A,B，且位数为2的整数次方，我们可以吧每个数按位数从中间分成两个数的和，如下图：<br><img src="https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98.png" alt="大数相乘"><br>将A分成a1和a0， 将B分成b1和b0<br>普通的做法是$A<em>B=a1</em>b1<em>10^n+(a1</em>b0+b1*a0)<em>10^(2/n)+a0</em>b0$</p>
<p>举个例子：</p>
<p>$1234<em>9876=（12</em>98）<em>10000+(12</em>76+98*34)<em>100+34</em>76$</p>
<p>对于这个算法的时间复杂度，我们需要做4次n/2级别的乘法和3加法。即T(n)=4*T(n/2)+O(n),时间复杂度是O(n²）.</p>
<p>分治法的算法是$A<em>B=a1</em>b1<em>10^n+[(a1+a0)</em>(b0+b1)-a1<em>a0-b1</em>b0]<em>10^n/2+a0</em>b0$</p>
<p>对于这个算法的时间复杂度，我们需要做3次n/2级别的乘法。即T(n)=3*T(n/2)+O(n),时间复杂度是T(n) = O(n^log2(3) ) = O(n^1.59).</p>
<details>
  <summary>分治法解决大数相乘问题的C语言实现代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> init_len = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (num1.length() &gt; <span class="number">2</span> || num2.length() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> max_len = max(num1.length(), num2.length());</span><br><span class="line">		<span class="keyword">while</span> (init_len &lt; max_len)	init_len *= <span class="number">2</span>;</span><br><span class="line">		add_pre_zero(num1, init_len - num1.length());</span><br><span class="line">		add_pre_zero(num2, init_len - num2.length());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num1.length() == <span class="number">1</span>) &#123;</span><br><span class="line">		add_pre_zero(num1, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num2.length() == <span class="number">1</span>) &#123;</span><br><span class="line">		add_pre_zero(num2, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = num1.length();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> a1, a0, b1, b0;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		a1 = num1.substr(<span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">		a0 = num1.substr(n / <span class="number">2</span>, n);</span><br><span class="line">		b1 = num2.substr(<span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">		b0 = num2.substr(n / <span class="number">2</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> x1 = atoi(a1.c_str());</span><br><span class="line">		<span class="keyword">int</span> x2 = atoi(a0.c_str());</span><br><span class="line">		<span class="keyword">int</span> y1 = atoi(b1.c_str());</span><br><span class="line">		<span class="keyword">int</span> y2 = atoi(b0.c_str());</span><br><span class="line">		<span class="keyword">int</span> z = (x1 * <span class="number">10</span> + x2) * (y1 * <span class="number">10</span> + y2);</span><br><span class="line">		result = to_string(z);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">string</span> c2 = multiply(a1, b1);</span><br><span class="line">		<span class="built_in">string</span> c0 = multiply(a0, b0);</span><br><span class="line">		<span class="built_in">string</span> temp_c1_1 = add(a0, a1);</span><br><span class="line">		<span class="built_in">string</span> temp_c1_2 = add(b1, b0);</span><br><span class="line">		<span class="built_in">string</span> temp_c1_3 = add(c2, c0);	</span><br><span class="line">		<span class="built_in">string</span> temp_c1 = multiply(temp_c1_1, temp_c1_2);</span><br><span class="line">		<span class="built_in">string</span> c1 = subtract(temp_c1, temp_c1_3);</span><br><span class="line">		<span class="built_in">string</span> s1 = add_last_zero(c1, n / <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">string</span> s2 = add_last_zero(c2, n);</span><br><span class="line">		result = add(add(s1, s2), c0);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h3 id="第K大数"><a href="#第K大数" class="headerlink" title="第K大数"></a>第K大数</h3><p>在一个未排序的数组中找到第k大的元素，注意此言的第k大就是排序后的第k大的数，</p>
<p>总是将要划界的数组段末尾的元素为划界元，将比其小的数交换至前，比其大的数交换至后，最后将划界元放在“中间位置”(左边小，右边大)。划界将数组分解成两个子数组(可能为空)。</p>
<p>设数组下表从low开始，至high结束。</p>
<ul>
<li>1.总是取要划界的数组末尾元素为划界元x，开始划界：<ul>
<li>a) 用j从low遍历到high-1(最后一个暂不处理)，i=low-1，如果nums[j]比x小就将nums[++i]与nums[j]交换位置.</li>
<li>b) 遍历完后再次将nums[i+1]与nums[high]交换位置(处理最后一个元素);</li>
<li>c) 返回划界元的位置i+1，下文称其为midpos.<br>这时的midpos位置的元素，此时就是整个数组中第N-midpos大的元素，我们所要做的就像二分法一样找到K=N-midpos的“中间位置”，即midpos=N-K.</li>
</ul>
</li>
<li>如果midpos==n-k，那么返回该值，这就是第k大的数。</li>
<li>如果midpos&gt;n-k，那么第k大的数在左半数组.</li>
<li>如果midpos&lt;n-k，那么第k大的数在右半数组.</li>
</ul>
<details>
  <summary>分治法解决第K大数问题的C语言实现代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路首先：</span></span><br><span class="line"><span class="comment">//快排划界，如果划界过程中当前划界元的中间位置就是k则找到了</span></span><br><span class="line"><span class="comment">//time,o(n*lg(k)),space,o(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//对数组vec，low到high的元素进行划界，并获取vec[high]的“中间位置”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickPartion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = vec[high];</span><br><span class="line">        <span class="keyword">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[j] &lt;= x)<span class="comment">//小于x的划到左边</span></span><br><span class="line">                swap(vec,++i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(vec,++i,high);<span class="comment">//找到划界元的位置</span></span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//返回位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换数组元素i和j的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getQuickSortK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> low,<span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> vec[low];</span><br><span class="line">        <span class="keyword">int</span>  midpos = quickPartion(vec, low,high);   <span class="comment">//对原数组vec[low]到vec[high]的元素进行划界</span></span><br><span class="line">        <span class="keyword">if</span> (midpos == vec.size() - k) <span class="comment">//如果midpos==n-k，那么返回该值，这就是第k大的数</span></span><br><span class="line">            <span class="keyword">return</span> vec[midpos];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midpos &lt; vec.size() - k) <span class="comment">//如果midpos&lt;n-k，那么第k大的数在右半数组</span></span><br><span class="line">            <span class="keyword">return</span> getQuickSortK(vec, midpos+<span class="number">1</span>, high, k);</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//如果midpos&gt;n-k，那么第k大的数在左半数组</span></span><br><span class="line">            <span class="keyword">return</span> getQuickSortK(vec, low, midpos<span class="number">-1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getQuickSortK(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h3 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h3><p>设有n=2^k个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</p>
<ul>
<li>(1)每个选手必须与其他n-1个选手各赛一次；</li>
<li>(2)每个选手一天只能参赛一次；</li>
<li>(3)循环赛在n-1天内结束。</li>
</ul>
<p>请按此要求将比赛日程表设计成有n行和n-1列的一个表。在表中的第i行，第j列处填入第i个选手在第j天所遇到的选手。其中1≤i≤n，1≤j≤n-1。8个选手的比赛日程表如下图：<br><img src="https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8.jpg" alt="循环赛日程表"></p>
<p>按分治策略，我们可以将所有的选手分为两半，则n个选手的比赛日程表可以通过n/2个选手的比赛日程表来决定。递归地用这种一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单。这时只要让这两个选手进行比赛就可以了。如上图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手1至选手4和选手5至选手8前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。依此思想容易将这个比赛日程表推广到具有任意多个选手的情形。</p>
<details>
  <summary>分治法解决循环赛日程表问题的C语言实现代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>][<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        a[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;  <span class="comment">//每次填充起始位置  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= k; s++) &#123;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; t++)  <span class="comment">//分的块数                        </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= <span class="number">2</span>*m; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = m+<span class="number">1</span>; j &lt;= <span class="number">2</span>*m; j++) &#123;</span><br><span class="line">                    a[i][j+(t<span class="number">-1</span>)*m*<span class="number">2</span>] = a[i-m][j+(t<span class="number">-1</span>)*m*<span class="number">2</span>-m];  <span class="comment">//右下角的值等于左上角的值</span></span><br><span class="line">                    a[i][j+(t<span class="number">-1</span>)*m*<span class="number">2</span>-m] = a[i-m][j+(t<span class="number">-1</span>)*m*<span class="number">2</span>];  <span class="comment">//左下角的值等于右上角的值</span></span><br><span class="line">                    <span class="comment">//printf(&quot;i = %d\t j+(t-1)*m*2 = %d\t j+(t-1)*m*2-m = %d\t, i-m=%d\n&quot;, i, j+(t-1)*m*2, j+(t-1)*m*2-m, i-m);</span></span><br><span class="line">                &#125;</span><br><span class="line">        m *= <span class="number">2</span>; <span class="comment">//更新填充起始位置  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">    table(k, n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i][j], j!=n?<span class="string">&#x27; &#x27;</span>:<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>ZhangHao</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://imzhanghao.com/2020/04/20/5-classic-algorithms-3-divide-and-conquer/">https://imzhanghao.com/2020/04/20/5-classic-algorithms-3-divide-and-conquer/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"># 分治算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/04/25/5-classic-algorithms-4-dynamic-programming/">五大经典算法|4.动态规划</a>
            
            
            <a class="next" rel="next" href="/2020/04/15/5-classic-algorithms-2-greedy-algorithm/">五大经典算法|2.贪心算法</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© ZhangHao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a><a target="_blank" href="https://beian.miit.gov.cn/"> | 陕ICP备20008129号</a></span>
    </div>
</footer>

    </div>
</body>
</html>
